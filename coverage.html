
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>aws: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cloudshave/cloudshaver/internal/pricing/aws/ec2_pricing.go (0.0%)</option>
				
				<option value="file1">github.com/cloudshave/cloudshaver/internal/pricing/aws/pricing.go (79.2%)</option>
				
				<option value="file2">github.com/cloudshave/cloudshaver/internal/pricing/aws/rds_pricing.go (84.2%)</option>
				
				<option value="file3">github.com/cloudshave/cloudshaver/internal/pricing/aws/service.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package aws

import (
        "encoding/json"
        "fmt"
        "reflect"
        "strings"

        "github.com/cloudshave/cloudshaver/internal/pricing/client"
)

const (
        EC2Service = "AmazonEC2"
        EBSService = "AmazonEBS"
)

// Constants for different pricing scenarios
const (
        // Operating Systems
        OSLinux   = "Linux"
        OSWindows = "Windows"
        OSRHEL    = "RHEL"
        OSSuse    = "SUSE"
        
        // Tenancy Types
        TenancyShared    = "Shared"
        TenancyDedicated = "Dedicated"
        TenancyHost      = "Host"
        
        // License Models
        LicenseIncluded  = "License included"
        LicenseNoLicense = "No License required"
        LicenseBYOL      = "Bring your own license"
        
        // Capacity Status
        CapacityUsed     = "Used"
        CapacityReserved = "Reserved"
        CapacitySpot     = "Spot"
        
        // Purchase Options
        PurchaseOnDemand = "On Demand"
        PurchaseReserved = "Reserved"
        PurchaseSpot     = "Spot"
)

type EC2PricingService struct {
        client           *client.PricingClient
        supportedRegions map[string]bool
}

type ProductAttributes struct {
        // Basic Instance Attributes
        InstanceType     string `json:"instanceType"`
        VCpu            string `json:"vcpu"`
        Memory          string `json:"memory"`
        Storage         string `json:"storage"`
        
        // Operating System and Software
        OperatingSystem string `json:"operatingSystem"`
        PreInstalledSw  string `json:"preInstalledSw"`
        LicenseModel    string `json:"licenseModel"`
        
        // Usage and Capacity
        UsageType       string `json:"usageType"`
        Operation       string `json:"operation"`
        CapacityStatus  string `json:"capacitystatus"`
        
        // Location and Tenancy
        Tenancy         string `json:"tenancy"`
        Location        string `json:"location"`
        LocationType    string `json:"locationType"`
        
        // Hardware Specifications
        ProcessorArchitecture    string `json:"processorArchitecture"`
        ProcessorFeatures       string `json:"processorFeatures"`
        PhysicalProcessor      string `json:"physicalProcessor"`
        ClockSpeed            string `json:"clockSpeed"`
        
        // Network
        NetworkPerformance           string `json:"networkPerformance"`
        NetworkBandwidthGbps        string `json:"networkBandwidthGbps"`
        NetworkBaselineGbps         string `json:"networkBaselineGbps"`
        NetworkPeakGbps             string `json:"networkPeakGbps"`
        EnhancedNetworkingSupported string `json:"enhancedNetworkingSupported"`
        
        // GPU
        GPU              string `json:"gpu"`
        GPUMemory        string `json:"gpuMemory"`
        GPUCount         string `json:"gpuCount"`
        
        // Instance Features
        CurrentGeneration           string `json:"currentGeneration"`
        InstanceFamily             string `json:"instanceFamily"`
        InstanceTypeFamily         string `json:"instanceTypeFamily"`
        DedicatedEbsThroughput     string `json:"dedicatedEbsThroughput"`
        EbsOptimizedSupport        string `json:"ebsOptimizedSupport"`
        
        // Volume Attributes
        VolumeType           string `json:"volumeType"`
        VolumeApiName        string `json:"volumeApiName"`
        MaxIopsvolume        string `json:"maxIopsvolume"`
        MaxThroughputvolume  string `json:"maxThroughputvolume"`
        
        // Additional Features
        Hibernation          string `json:"hibernationSupported"`
        BurstablePerformance string `json:"burstablePerformance"`
        AutoRecovery         string `json:"autoRecovery"`
}

type PriceDimension struct {
        Unit         string            `json:"unit"`
        PricePerUnit map[string]string `json:"pricePerUnit"`
        Description  string            `json:"description"`
}

type TermAttributes struct {
        LeaseContractLength string `json:"LeaseContractLength"`
        PurchaseOption      string `json:"PurchaseOption"`
        OfferingClass       string `json:"OfferingClass"`
}

type PriceFilter struct {
        Attribute string
        Value    string
}

type PricingOptions struct {
    OperatingSystem string
    Tenancy        string
    LicenseModel   string
    CapacityType   string   // On-Demand, Reserved, Spot
    ReservedTerm   string   // 1yr, 3yr
    PaymentOption  string   // No Upfront, Partial Upfront, All Upfront
    OfferingClass  string   // Standard, Convertible
    PreInstalledSw string
}

type PricingDetails struct {
    OnDemandPrice   float64
    SpotPrice       float64
    ReservedPricing map[string]ReservedPricing  // Key: term-payment-class
    Attributes      ProductAttributes
}

type ReservedPricing struct {
    UpfrontFee     float64
    HourlyPrice    float64
    EffectivePrice float64  // Calculated for the term
    Term           string
    PaymentOption  string
    OfferingClass  string
}

type EC2Instance struct {
    Type           string
    Region         string
    PricingOptions PricingOptions
    Usage          InstanceUsage
}

type InstanceUsage struct {
    AverageUtilization float64
    PeakUtilization   float64
    BurstableCredits  float64
    StorageGB         int
    IOPS             int
    Throughput       int
}

type SavingsAnalysis struct {
    CurrentInstance    EC2Instance
    TargetInstance    EC2Instance
    HourlySavings     float64
    DailySavings      float64
    MonthlySavings    float64
    YearlySavings     float64
    ReservedSavings   *ReservedSavings
    SpotSavings       *SpotSavings
    Recommendations   []string
}

type ReservedSavings struct {
    Term                  string
    UpfrontSavings       float64
    EffectiveHourlySavings float64
    PaybackPeriodMonths   float64
}

type SpotSavings struct {
    AverageHourlySavings float64
    InterruptionRisk     float64
    RecommendedStrategy  string
}

// NewEC2PricingService creates a new EC2 pricing service
func NewEC2PricingService(region string) (*EC2PricingService, error) <span class="cov0" title="0">{
        client := client.NewPricingClient(region)

        // Get list of supported regions
        index, err := client.GetServiceIndex()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get service index: %w", err)
        }</span>

        <span class="cov0" title="0">supportedRegions := make(map[string]bool)
        if ec2Offer, ok := index.Offers[EC2Service]; ok </span><span class="cov0" title="0">{
                for region := range ec2Offer.Regions </span><span class="cov0" title="0">{
                        supportedRegions[region] = true
                }</span>
        }

        <span class="cov0" title="0">return &amp;EC2PricingService{
                client:           client,
                supportedRegions: supportedRegions,
        }, nil</span>
}

// IsRegionSupported checks if a region is supported for pricing
func (s *EC2PricingService) IsRegionSupported(region string) bool <span class="cov0" title="0">{
        return s.supportedRegions[region]
}</span>

// GetInstancePrice retrieves the price for a specific EC2 instance type
func (s *EC2PricingService) GetInstancePrice(instanceType, region string, filters ...PriceFilter) (float64, error) <span class="cov0" title="0">{
    // Ensure the region is supported
    if !s.IsRegionSupported(region) </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("region %s is not supported for EC2 pricing", region)
    }</span>

    // Get pricing data for the specific region
    <span class="cov0" title="0">data, err := s.client.GetServicePricing(EC2Service, region)
    if err != nil </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("failed to get EC2 pricing data: %w", err)
    }</span>

    // Parse the pricing data
    <span class="cov0" title="0">var pricing struct {
        Products map[string]struct {
            Attributes ProductAttributes `json:"attributes"`
            Sku       string            `json:"sku"`
        } `json:"products"`
        Terms struct {
            OnDemand map[string]map[string]struct {
                PriceDimensions map[string]PriceDimension `json:"priceDimensions"`
                TermAttributes TermAttributes `json:"termAttributes"`
            } `json:"OnDemand"`
            Reserved map[string]map[string]struct {
                PriceDimensions map[string]PriceDimension `json:"priceDimensions"`
                TermAttributes TermAttributes `json:"termAttributes"`
            } `json:"Reserved"`
        } `json:"terms"`
    }

    if err := json.Unmarshal(data, &amp;pricing); err != nil </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("failed to parse pricing data: %w", err)
    }</span>

    // Default filters if none provided
    <span class="cov0" title="0">if len(filters) == 0 </span><span class="cov0" title="0">{
        filters = []PriceFilter{
            {
                Attribute: "operatingSystem",
                Value:    OSLinux,
            },
            {
                Attribute: "preInstalledSw",
                Value:    "NA",
            },
            {
                Attribute: "capacitystatus",
                Value:    CapacityUsed,
            },
            {
                Attribute: "tenancy",
                Value:    TenancyShared,
            },
            {
                Attribute: "licenseModel",
                Value:    LicenseNoLicense,
            },
        }
    }</span>

    // Find the matching instance type with all filters
    <span class="cov0" title="0">var matchingSku string
    for sku, product := range pricing.Products </span><span class="cov0" title="0">{
        attrs := product.Attributes
        if attrs.InstanceType != instanceType </span><span class="cov0" title="0">{
            continue</span>
        }

        // Apply all filters
        <span class="cov0" title="0">matches := true
        for _, filter := range filters </span><span class="cov0" title="0">{
            attrValue := getAttributeValue(attrs, filter.Attribute)
            if attrValue != filter.Value </span><span class="cov0" title="0">{
                matches = false
                break</span>
            }
        }

        <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
            matchingSku = sku
            break</span>
        }
    }

    <span class="cov0" title="0">if matchingSku == "" </span><span class="cov0" title="0">{
        return 0, fmt.Errorf("no matching product found for instance type %s in region %s with specified filters", instanceType, region)
    }</span>

    // Find the price in terms
    <span class="cov0" title="0">for _, term := range pricing.Terms.OnDemand </span><span class="cov0" title="0">{
        for _, price := range term </span><span class="cov0" title="0">{
            for _, dimension := range price.PriceDimensions </span><span class="cov0" title="0">{
                if dimension.Unit == "Hrs" </span><span class="cov0" title="0">{
                    return parsePrice(dimension.PricePerUnit["USD"])
                }</span>
            }
        }
    }

    <span class="cov0" title="0">return 0, fmt.Errorf("no pricing found for instance type %s in region %s", instanceType, region)</span>
}

// GetVolumePrice retrieves the price for a specific EBS volume type
func (s *EC2PricingService) GetVolumePrice(volumeType, region string) (float64, error) <span class="cov0" title="0">{
        data, err := s.client.GetServicePricing(EBSService, region)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">var pricing struct {
                Products map[string]struct {
                        Attributes ProductAttributes `json:"attributes"`
                } `json:"products"`
                Terms struct {
                        OnDemand map[string]map[string]struct {
                                PriceDimensions map[string]PriceDimension `json:"priceDimensions"`
                        } `json:"OnDemand"`
                } `json:"terms"`
        }

        if err := json.Unmarshal(data, &amp;pricing); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse EBS pricing: %v", err)
        }</span>

        // Find the product ID for the volume type
        <span class="cov0" title="0">var productID string
        for id, product := range pricing.Products </span><span class="cov0" title="0">{
                attrs := product.Attributes
                if strings.EqualFold(attrs.VolumeType, volumeType) </span><span class="cov0" title="0">{
                        productID = id
                        break</span>
                }
        }

        <span class="cov0" title="0">if productID == "" </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("volume type %s not found in pricing data", volumeType)
        }</span>

        // Find the price for the product
        <span class="cov0" title="0">for _, term := range pricing.Terms.OnDemand[productID] </span><span class="cov0" title="0">{
                for _, dimension := range term.PriceDimensions </span><span class="cov0" title="0">{
                        if dimension.Unit == "GB-Mo" </span><span class="cov0" title="0">{
                                for _, price := range dimension.PricePerUnit </span><span class="cov0" title="0">{
                                        return parsePrice(price)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return 0, fmt.Errorf("no pricing found for volume type %s", volumeType)</span>
}

// CalculateInstanceSavings calculates potential savings for an EC2 instance
func (s *EC2PricingService) CalculateInstanceSavings(currentType, targetType, region string) (float64, error) <span class="cov0" title="0">{
        currentPrice, err := s.GetInstancePrice(currentType, region)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get current instance price: %v", err)
        }</span>

        <span class="cov0" title="0">targetPrice, err := s.GetInstancePrice(targetType, region)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get target instance price: %v", err)
        }</span>

        <span class="cov0" title="0">hourlyDiff := currentPrice - targetPrice
        monthlySavings := hourlyDiff * 730 // Average hours in a month

        return monthlySavings, nil</span>
}

// CalculateVolumeSavings calculates potential savings for an EBS volume
func (s *EC2PricingService) CalculateVolumeSavings(currentType, targetType string, sizeGB int, region string) (float64, error) <span class="cov0" title="0">{
        currentPrice, err := s.GetVolumePrice(currentType, region)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get current volume price: %v", err)
        }</span>

        <span class="cov0" title="0">targetPrice, err := s.GetVolumePrice(targetType, region)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to get target volume price: %v", err)
        }</span>

        <span class="cov0" title="0">monthlySavings := float64(sizeGB) * (currentPrice - targetPrice)
        return monthlySavings, nil</span>
}

func DefaultPricingOptions() PricingOptions <span class="cov0" title="0">{
    return PricingOptions{
        OperatingSystem: OSLinux,
        Tenancy:        TenancyShared,
        LicenseModel:   LicenseNoLicense,
        CapacityType:   PurchaseOnDemand,
        PreInstalledSw: "NA",
    }
}</span>

func (s *EC2PricingService) GetInstancePriceDetailed(instanceType, region string, options PricingOptions) (*PricingDetails, error) <span class="cov0" title="0">{
    filters := []PriceFilter{
        {Attribute: "instanceType", Value: instanceType},
        {Attribute: "operatingSystem", Value: options.OperatingSystem},
        {Attribute: "tenancy", Value: options.Tenancy},
        {Attribute: "licenseModel", Value: options.LicenseModel},
        {Attribute: "preInstalledSw", Value: options.PreInstalledSw},
    }

    data, err := s.client.GetServicePricing(EC2Service, region)
    if err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("failed to get EC2 pricing data: %w", err)
    }</span>

    <span class="cov0" title="0">var pricing struct {
        Products map[string]struct {
            Attributes ProductAttributes `json:"attributes"`
            Sku       string            `json:"sku"`
        } `json:"products"`
        Terms struct {
            OnDemand map[string]map[string]struct {
                PriceDimensions map[string]PriceDimension `json:"priceDimensions"`
                TermAttributes TermAttributes             `json:"termAttributes"`
            } `json:"OnDemand"`
            Reserved map[string]map[string]struct {
                PriceDimensions map[string]PriceDimension `json:"priceDimensions"`
                TermAttributes TermAttributes             `json:"termAttributes"`
            } `json:"Reserved"`
        } `json:"terms"`
    }

    if err := json.Unmarshal(data, &amp;pricing); err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("failed to parse pricing data: %w", err)
    }</span>

    <span class="cov0" title="0">details := &amp;PricingDetails{
        ReservedPricing: make(map[string]ReservedPricing),
    }

    // Find matching product
    var matchingSku string
    for sku, product := range pricing.Products </span><span class="cov0" title="0">{
        attrs := product.Attributes
        matches := true
        for _, filter := range filters </span><span class="cov0" title="0">{
            if getAttributeValue(attrs, filter.Attribute) != filter.Value </span><span class="cov0" title="0">{
                matches = false
                break</span>
            }
        }
        <span class="cov0" title="0">if matches </span><span class="cov0" title="0">{
            matchingSku = sku
            details.Attributes = attrs
            break</span>
        }
    }

    <span class="cov0" title="0">if matchingSku == "" </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("no matching product found for instance type %s in region %s", instanceType, region)
    }</span>

    // Get On-Demand price
    <span class="cov0" title="0">for _, term := range pricing.Terms.OnDemand </span><span class="cov0" title="0">{
        for _, price := range term </span><span class="cov0" title="0">{
            for _, dimension := range price.PriceDimensions </span><span class="cov0" title="0">{
                if dimension.Unit == "Hrs" </span><span class="cov0" title="0">{
                    details.OnDemandPrice, _ = parsePrice(dimension.PricePerUnit["USD"])
                    break</span>
                }
            }
        }
    }

    // Get Reserved Instance prices
    <span class="cov0" title="0">for _, term := range pricing.Terms.Reserved </span><span class="cov0" title="0">{
        for _, price := range term </span><span class="cov0" title="0">{
            attrs := price.TermAttributes
            key := fmt.Sprintf("%s-%s-%s", attrs.LeaseContractLength, attrs.PurchaseOption, attrs.OfferingClass)
            
            rp := ReservedPricing{
                Term:          attrs.LeaseContractLength,
                PaymentOption: attrs.PurchaseOption,
                OfferingClass: attrs.OfferingClass,
            }

            for _, dimension := range price.PriceDimensions </span><span class="cov0" title="0">{
                if dimension.Unit == "Hrs" </span><span class="cov0" title="0">{
                    rp.HourlyPrice, _ = parsePrice(dimension.PricePerUnit["USD"])
                }</span> else<span class="cov0" title="0"> if dimension.Unit == "Quantity" </span><span class="cov0" title="0">{
                    rp.UpfrontFee, _ = parsePrice(dimension.PricePerUnit["USD"])
                }</span>
            }

            // Calculate effective hourly price
            <span class="cov0" title="0">hours := 8760.0 // 1 year
            if attrs.LeaseContractLength == "3yr" </span><span class="cov0" title="0">{
                hours = 26280.0
            }</span>
            <span class="cov0" title="0">rp.EffectivePrice = rp.HourlyPrice + (rp.UpfrontFee / hours)

            details.ReservedPricing[key] = rp</span>
        }
    }

    <span class="cov0" title="0">return details, nil</span>
}

func (s *EC2PricingService) CalculateDetailedSavings(current, target EC2Instance) (*SavingsAnalysis, error) <span class="cov0" title="0">{
    currentPricing, err := s.GetInstancePriceDetailed(current.Type, current.Region, current.PricingOptions)
    if err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("failed to get current instance pricing: %w", err)
    }</span>

    <span class="cov0" title="0">targetPricing, err := s.GetInstancePriceDetailed(target.Type, target.Region, target.PricingOptions)
    if err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("failed to get target instance pricing: %w", err)
    }</span>

    <span class="cov0" title="0">analysis := &amp;SavingsAnalysis{
        CurrentInstance: current,
        TargetInstance: target,
        HourlySavings: currentPricing.OnDemandPrice - targetPricing.OnDemandPrice,
    }

    // Calculate time-based savings
    analysis.DailySavings = analysis.HourlySavings * 24
    analysis.MonthlySavings = analysis.HourlySavings * 730  // Average hours per month
    analysis.YearlySavings = analysis.HourlySavings * 8760

    // Calculate Reserved Instance savings
    if riPricing, ok := targetPricing.ReservedPricing["1yr-partial-standard"]; ok </span><span class="cov0" title="0">{
        yearlyOnDemand := currentPricing.OnDemandPrice * 8760
        yearlyReserved := riPricing.UpfrontFee + (riPricing.HourlyPrice * 8760)
        
        analysis.ReservedSavings = &amp;ReservedSavings{
            Term: "1yr",
            UpfrontSavings: yearlyOnDemand - yearlyReserved,
            EffectiveHourlySavings: currentPricing.OnDemandPrice - riPricing.EffectivePrice,
            PaybackPeriodMonths: (riPricing.UpfrontFee / analysis.MonthlySavings),
        }
    }</span>

    // Add recommendations based on usage patterns
    <span class="cov0" title="0">analysis.Recommendations = s.generateRecommendations(current, target, currentPricing, targetPricing)

    return analysis, nil</span>
}

func (s *EC2PricingService) generateRecommendations(current, target EC2Instance, currentPricing, targetPricing *PricingDetails) []string <span class="cov0" title="0">{
    var recommendations []string

    // Check for cost-effective instance type
    if current.Usage.AverageUtilization &lt; 40 </span><span class="cov0" title="0">{
        recommendations = append(recommendations, fmt.Sprintf(
            "Consider downsizing from %s to %s due to low utilization (%.1f%%)",
            current.Type, target.Type, current.Usage.AverageUtilization,
        ))
    }</span>

    // Check for Reserved Instance opportunities
    <span class="cov0" title="0">if current.PricingOptions.CapacityType == PurchaseOnDemand </span><span class="cov0" title="0">{
        if riPricing, ok := targetPricing.ReservedPricing["1yr-partial-standard"]; ok </span><span class="cov0" title="0">{
            savings := (currentPricing.OnDemandPrice - riPricing.EffectivePrice) * 8760
            if savings &gt; 1000 </span><span class="cov0" title="0">{ // If yearly savings exceed $1000
                recommendations = append(recommendations, fmt.Sprintf(
                    "Consider Reserved Instance for %s to save approximately $%.2f per year",
                    target.Type, savings,
                ))
            }</span>
        }
    }

    // Check for burstable instance opportunities
    <span class="cov0" title="0">if current.Usage.PeakUtilization &lt; 20 </span><span class="cov0" title="0">{
        recommendations = append(recommendations, fmt.Sprintf(
            "Consider using a burstable instance type for %s due to very low peak utilization (%.1f%%)",
            current.Type, current.Usage.PeakUtilization,
        ))
    }</span>

    <span class="cov0" title="0">return recommendations</span>
}

func parsePrice(price string) (float64, error) <span class="cov0" title="0">{
        var value float64
        if _, err := fmt.Sscanf(price, "%f", &amp;value); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to parse price %s: %v", price, err)
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}

func getAttributeValue(attrs ProductAttributes, attributeName string) string <span class="cov0" title="0">{
        r := reflect.ValueOf(attrs)
        f := reflect.Indirect(r).FieldByNameFunc(func(s string) bool </span><span class="cov0" title="0">{
                return strings.EqualFold(s, attributeName)
        }</span>)
        
        <span class="cov0" title="0">if !f.IsValid() </span><span class="cov0" title="0">{
                return ""
        }</span>
        
        <span class="cov0" title="0">return f.String()</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package aws

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// EC2Pricing holds pricing information for EC2 instances and EBS volumes
type EC2Pricing struct {
        RegionMapping map[string]map[string]InstancePricing
        EBSVolumes    map[string]map[string]VolumePricing
        dataDir       string
}

// InstancePricing represents pricing information for an EC2 instance type
type InstancePricing struct {
        OnDemandPrice float64 `json:"onDemandPrice"`
}

// VolumePricing represents pricing information for an EBS volume type
type VolumePricing struct {
        PricePerGBMonth float64 `json:"pricePerGBMonth"`
}

// NewEC2Pricing creates a new EC2Pricing instance
func NewEC2Pricing(dataDir string) *EC2Pricing <span class="cov8" title="1">{
        return &amp;EC2Pricing{
                RegionMapping: make(map[string]map[string]InstancePricing),
                EBSVolumes:    make(map[string]map[string]VolumePricing),
                dataDir:       dataDir,
        }
}</span>

// LoadPricing loads EC2 pricing data from JSON files
func (p *EC2Pricing) LoadPricing() error <span class="cov8" title="1">{
        // Load instance pricing
        instanceData, err := os.ReadFile(filepath.Join(p.dataDir, "data", "ec2_pricing.json"))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read EC2 pricing data: %v", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(instanceData, &amp;p.RegionMapping); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse EC2 pricing data: %v", err)
        }</span>

        // Load EBS volume pricing
        <span class="cov8" title="1">volumeData, err := os.ReadFile(filepath.Join(p.dataDir, "data", "ebs_pricing.json"))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read EBS pricing data: %v", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(volumeData, &amp;p.EBSVolumes); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse EBS pricing data: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsRegionSupported checks if pricing is supported for the given region
func (p *EC2Pricing) IsRegionSupported(region string) bool <span class="cov8" title="1">{
        _, ok := p.RegionMapping[region]
        return ok
}</span>

// CalculateInstanceSavings calculates potential savings when upgrading from one instance type to another
func (p *EC2Pricing) CalculateInstanceSavings(currentType, targetType, region string) (float64, error) <span class="cov8" title="1">{
        if !p.IsRegionSupported(region) </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("region %s is not supported", region)
        }</span>

        <span class="cov8" title="1">currentPricing, ok := p.RegionMapping[region][currentType]
        if !ok </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("no pricing data available for instance type %s", currentType)
        }</span>

        <span class="cov8" title="1">targetPricing, ok := p.RegionMapping[region][targetType]
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("no pricing data available for instance type %s", targetType)
        }</span>

        // Calculate monthly savings (assuming 720 hours per month)
        <span class="cov8" title="1">monthlySavings := (currentPricing.OnDemandPrice - targetPricing.OnDemandPrice) * 720
        return monthlySavings, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package aws

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// RDSPricing holds pricing information for RDS instances
type RDSPricing struct {
        RegionMapping map[string]map[string]RDSInstancePricing
        dataDir       string
}

// RDSInstancePricing represents pricing information for an RDS instance type
type RDSInstancePricing struct {
        OnDemandPrice float64 `json:"onDemandPrice"`
}

// NewRDSPricing creates a new RDSPricing instance
func NewRDSPricing(dataDir string) *RDSPricing <span class="cov8" title="1">{
        return &amp;RDSPricing{
                RegionMapping: make(map[string]map[string]RDSInstancePricing),
                dataDir:       dataDir,
        }
}</span>

// LoadPricing loads RDS pricing data from JSON files
func (p *RDSPricing) LoadPricing() error <span class="cov8" title="1">{
        // Load instance pricing
        data, err := os.ReadFile(filepath.Join(p.dataDir, "internal", "pricing", "aws", "data", "rds_pricing.json"))
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read RDS pricing data: %v", err)
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(data, &amp;p.RegionMapping); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse RDS pricing data: %v", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsRegionSupported checks if pricing is supported for the given region
func (p *RDSPricing) IsRegionSupported(region string) bool <span class="cov8" title="1">{
        _, ok := p.RegionMapping[region]
        return ok
}</span>

// CalculateInstanceSavings calculates potential savings when upgrading from one instance type to another
func (p *RDSPricing) CalculateInstanceSavings(currentType, targetType, region string) (float64, error) <span class="cov8" title="1">{
        if !p.IsRegionSupported(region) </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("region %s is not supported", region)
        }</span>

        <span class="cov8" title="1">currentPricing, ok := p.RegionMapping[region][currentType]
        if !ok </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("no pricing data available for instance type %s", currentType)
        }</span>

        <span class="cov8" title="1">targetPricing, ok := p.RegionMapping[region][targetType]
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("no pricing data available for instance type %s", targetType)
        }</span>

        // Calculate monthly savings (assuming 720 hours per month)
        <span class="cov8" title="1">monthlySavings := (currentPricing.OnDemandPrice - targetPricing.OnDemandPrice) * 720
        return monthlySavings, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package aws

import (
        "fmt"
        "os"
        "path/filepath"
        awsinterfaces "github.com/cloudshave/cloudshaver/internal/interfaces/aws"
)

// PricingService implements the PricingServiceAPI interface
type PricingService struct {
        ec2Pricing *EC2Pricing
        rdsPricing *RDSPricing
}

// NewPricingService creates a new instance of PricingService
func NewPricingService() (awsinterfaces.PricingServiceAPI, error) <span class="cov0" title="0">{
        execPath, err := os.Executable()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get executable path: %v", err)
        }</span>
        <span class="cov0" title="0">execDir := filepath.Dir(execPath)

        service := &amp;PricingService{
                ec2Pricing: NewEC2Pricing(execDir),
                rdsPricing: NewRDSPricing(execDir),
        }

        if err := service.LoadPricing(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load pricing data: %v", err)
        }</span>

        <span class="cov0" title="0">return service, nil</span>
}

// LoadPricing loads pricing data for both EC2 and RDS
func (s *PricingService) LoadPricing() error <span class="cov0" title="0">{
        if err := s.ec2Pricing.LoadPricing(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load EC2 pricing: %v", err)
        }</span>
        <span class="cov0" title="0">if err := s.rdsPricing.LoadPricing(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to load RDS pricing: %v", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CalculateInstanceSavings calculates potential savings for an instance
func (s *PricingService) CalculateInstanceSavings(currentType, targetType, region string) (float64, error) <span class="cov0" title="0">{
        // Try EC2 pricing first
        savings, err := s.ec2Pricing.CalculateInstanceSavings(currentType, targetType, region)
        if err == nil </span><span class="cov0" title="0">{
                return savings, nil
        }</span>

        // If EC2 pricing fails, try RDS pricing
        <span class="cov0" title="0">savings, err = s.rdsPricing.CalculateInstanceSavings(currentType, targetType, region)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to calculate savings: %v", err)
        }</span>

        <span class="cov0" title="0">return savings, nil</span>
}

// IsRegionSupported checks if the given region is supported
func (s *PricingService) IsRegionSupported(region string) bool <span class="cov0" title="0">{
        return s.ec2Pricing.IsRegionSupported(region) || s.rdsPricing.IsRegionSupported(region)
}</span>

// GetVolumePrice returns the price per GB-month for the given volume type in the specified region
func (s *PricingService) GetVolumePrice(volumeType, region string) (float64, error) <span class="cov0" title="0">{
        if !s.IsRegionSupported(region) </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("region %s is not supported", region)
        }</span>

        <span class="cov0" title="0">regionPricing, ok := s.ec2Pricing.EBSVolumes[region]
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("no pricing data available for region %s", region)
        }</span>

        <span class="cov0" title="0">volume, ok := regionPricing[volumeType]
        if !ok </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("no pricing data available for volume type %s", volumeType)
        }</span>

        <span class="cov0" title="0">return volume.PricePerGBMonth, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
